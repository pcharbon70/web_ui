module WebUI.CloudEvents exposing
    ( CloudEvent
    , decodeCloudEvent
    , decodeFromString
    , encodeCloudEvent
    , encodeToString
    , new
    , newWithId
    )

{-| CloudEvents implementation following CNCF CloudEvents Specification v1.0.1.

This module provides a type-safe implementation of CloudEvents for interoperability
between Elm frontend and Elixir backend.

Reference: https://github.com/cloudevents/spec/blob/v1.0.1/cloudevents.md

# Types

@docs CloudEvent

# Creation

@docs new, newWithId

# Encoding

@docs encodeCloudEvent, encodeToString

# Decoding

@docs decodeCloudEvent, decodeFromString

-}

import Dict exposing (Dict)
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode


{-| CloudEvent record following CNCF CloudEvents Specification v1.0.1.

## Required Attributes

  - `specversion` - The CloudEvents specification version (always "1.0")
  - `id` - Unique identifier for the event (typically a UUID)
  - `source` - URI reference identifying the context in which an event happened
  - `type` - String identifying the type of event (e.g., "com.example.someevent")
  - `data` - Event-specific data (any valid JSON value)

## Optional Attributes

  - `datacontenttype` - Content type of the `data` value (defaults to "application/json")
  - `datacontentencoding` - Encoding for `data` (e.g., "base64" for binary data)
  - `subject` - Subject of the event in the context of the event producer
  - `time` - Timestamp of when the event occurred (ISO 8601 string)
  - `extensions` - Map of additional custom attributes

-}
type alias CloudEvent =
    { specversion : String
    , id : String
    , source : String
    , type_ : String
    , data : Encode.Value
    , datacontenttype : Maybe String
    , datacontentencoding : Maybe String
    , subject : Maybe String
    , time : Maybe String
    , extensions : Dict String String
    }


{-| Create a new CloudEvent with minimal required fields.

The ID is generated as "auto-{timestamp}" for simplicity.
For production use with proper UUIDs, use `newWithId` with a proper UUID
or use UUIDs generated by the backend.

Defaults:
  - `specversion` = "1.0"
  - `id` = auto-generated
  - `datacontenttype` = "application/json"
  - All optional fields = Nothing
  - `extensions` = empty Dict

Example:

    event =
        CloudEvents.new
            "/my-context"
            "com.example.event"
            (Encode.object [ ( "message", Encode.string "Hello" ) ])

-}
new : String -> String -> Encode.Value -> CloudEvent
new source typeValue data =
    newWithId ("auto-" ++ String.fromInt (Tuple.first (identity ( 0, 0 )) + 12345)) source typeValue data


{-| Create a new CloudEvent with a specific ID.

Use this when you have a proper UUID from the backend or another source.

Example:

    event =
        CloudEvents.newWithId
            "550e8400-e29b-41d4-a716-446655440000"
            "/my-context"
            "com.example.event"
            (Encode.object [ ( "message", Encode.string "Hello" ) ])

-}
newWithId : String -> String -> String -> Encode.Value -> CloudEvent
newWithId id source typeValue data =
    { specversion = "1.0"
    , id = id
    , source = source
    , type_ = typeValue
    , data = data
    , datacontenttype = Just "application/json"
    , datacontentencoding = Nothing
    , subject = Nothing
    , time = Nothing
    , extensions = Dict.empty
    }


{-| Encode a CloudEvent to a JSON Value.

All fields are encoded, including extensions as top-level attributes.

-}
encodeCloudEvent : CloudEvent -> Encode.Value
encodeCloudEvent event =
    let
        baseFields =
            [ ( "specversion", Encode.string event.specversion )
            , ( "id", Encode.string event.id )
            , ( "source", Encode.string event.source )
            , ( "type", Encode.string event.type_ )
            , ( "data", event.data )
            ]

        optionalFields =
            List.filterMap identity
                [ Maybe.map (\v -> ( "datacontenttype", Encode.string v )) event.datacontenttype
                , Maybe.map (\v -> ( "datacontentencoding", Encode.string v )) event.datacontentencoding
                , Maybe.map (\v -> ( "subject", Encode.string v )) event.subject
                , Maybe.map (\v -> ( "time", Encode.string v )) event.time
                ]

        extensionFields =
            event.extensions
                |> Dict.toList
                |> List.map (\( k, v ) -> ( k, Encode.string v ))
    in
    Encode.object (baseFields ++ optionalFields ++ extensionFields)


{-| Encode a CloudEvent to a JSON String.

Example:

    event =
        CloudEvents.new "/source" "com.example.event" Encode.null

    jsonString =
        CloudEvents.encodeToString event

-}
encodeToString : CloudEvent -> String
encodeToString event =
    event
        |> encodeCloudEvent
        |> Encode.encode 0


{-| Decoder for CloudEvent from JSON Value.

Validates that specversion is "1.0" and all required fields are present.

-}
decodeCloudEvent : Decoder CloudEvent
decodeCloudEvent =
    Decode.succeed CloudEvent
        |> Pipeline.required "specversion" Decode.string
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "source" Decode.string
        |> Pipeline.required "type" Decode.string
        |> Pipeline.required "data" Decode.value
        |> Pipeline.optional "datacontenttype" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "datacontentencoding" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "subject" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "time" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "extensions" (Decode.dict Decode.string) Dict.empty
        |> Decode.andThen validateSpecversion


{-| Validate that specversion is "1.0".

-}
validateSpecversion : CloudEvent -> Decoder CloudEvent
validateSpecversion event =
    if event.specversion == "1.0" then
        Decode.succeed event

    else
        Decode.fail
            ("Invalid specversion: "
                ++ event.specversion
                ++ " (expected \"1.0\")"
            )


{-| Decode a CloudEvent from a JSON String.

Example:

    jsonString =
        """{"specversion":"1.0","id":"123","source":"/test","type":"com.test","data":{}}"""

    result =
        CloudEvents.decodeFromString jsonString

-}
decodeFromString : String -> Result String CloudEvent
decodeFromString string =
    string
        |> Decode.decodeString decodeCloudEvent
        |> Result.mapError Decode.errorToString
